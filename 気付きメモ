ポートフォリオ作成時のメモ

●データベースの文字コード
どれを選択すればいいのだろう・・
「utf-8mb4」にする

utf-8mb4では、1文字４バイトだが、
utf8は、1文字３バイト。
違い：絵文字は４バイト

MySQL5.5以上ならutf-8mb4を使用出来る。
2019年はガンガン使っていいと思うし、懇親目的の掲示板だから、使う。

・掲示板（PHP教科書）
utf8mb4_general_ci
・ショップ（気づけばプロ並み）
utf8_unicode_ci
・news（勉強会、ニュース更新のやつ）
utf8_general_ci

ちなみに
general：正確性重視（例:『 ß 』と『 s 』を区別する）
unicode：速度重視例（『 ß 』と『 s 』を区別しない）
bin：バイナリ（文字コード）で比較する
ci：探索で英字の大文字小文字を区別しない

●データベース型 charとvarchar
https://qiita.com/oh_seibo/items/c589430bdb00c6ab4922
char(10):固定長の文字列データを扱う、データ型
・格納される列は常に10バイトになる（超える分は削られる。多分）
・10バイトに満たない場合は、文字列の右側に空白が追加され、10バイトぴったりに調整される
・郵便番号や社員番号など、データの桁数が決まっているものに向いている

varchar(10):格納する文字列の長さの調整はされない
・10バイト以下の文字列でも、それに合わせた領域が確保される為、そのままの長さで格納することが可能
・ただし、最大長以上の文字列は格納できない
・氏名や書籍名など、データ桁数が変動する可能性のあるものに向いている

●文字種類／文字コード／1文字あたりのバイト数
ASCⅡ／UTF8／1
半角カナ／UTF8／3
JIS X 0208漢字／UTF8／3

●パスワードの暗号化
・ショップ（気づけばプロ並み）
$staff_pass = md5($staff_pass);
だが、P70コラムにて、password_hash関数を推奨している。

・qiitaにて
https://qiita.com/rana_kualu/items/3ef57485be1103362f56
ログイン認証と称してmd5とかsha1とか書いてあるソースはゴミなので投げ捨てましょう。
hashやcryptは上記に比べればずっとマシですが、使い方によっては簡単に脆弱になりえます。
あと『パスワードを暗号化する』って表現してるところも見なくていいです。

PHPには、ハッシュに関わる諸々の落とし穴を一発で解消してくれるpassword_hashという超絶便利関数があるので、これを使います。
というか、これ以外を使ってはいけません。

・・・
結論
ソーシャルログインにしとけ。
どうしても必要ならフレームワーク使え。

→今回は勉強の意味で、ソーシャルログインは使用しない。password_hashを採用する！

●安全対策
・ショップ（気づけばプロ並み）
P72コラム。サニタイジングが不要なプログラムが理想だが、それはまだ先（高度な技術が必要。）
せめて、それを自動化するべし！
htmlspecialchars($string,ENT_QUOTES,'UTF-8');を関数化するなど
(対象文字列、エンコードのフラグ、文字コード)

HTMLタグやスクリプトコードを「HTMLエンティティ」へ変換し、無効化することができます。HTMLエンティティとは、文字の素の姿のようなもの。

例えば、HTMLタグ記述で使う「<」であれば、HTMLエンティティは「&lt;」です。同じように、他の文字にも対応するHTMLエンティティが存在します。
HTMLファイルに「<br>」と書くと普通に改行が入ってしまいますが、HTMLエンティティで「&lt;br&gt;」と書けば、HTMLタグとして認識されずに通常テキストとして出力することができます。改行もされません。
2つ目のパラメータは変換ルールを指定する定数が入ります。指定できる値は数種類ありますが、今回は「ENT_QUOTES」を指定します。
「ENT_QUOTES」はシングルクォート、ダブルクォートのどちらもHTMLエンティティへ変換する対象とします。

●データベース、２つのテーブル参照
UNION ALLを検討するも、やりたいこと少し違うので、２度参照した

●login_checkにて、データベース呼び出しを
Db::dbconnect
でやるとどうしてもエラーになるので、インスタンスを作成して対応した。

●単語「check」を使わないようにした（広義過ぎて、可読性が低い）
check_emailをis_emailにしたり、
validationのcheckメソッドをisEmailにしたり

●checkboxの処理
３つ選択にしているので、POSTでの受取を配列で実施。

●空白かどうか、===は避けた方が良い
https://qiita.com/mpyw/items/2f9955db1c02eeef43ea

空要素かの判断

・empty($var)
$varは変数でないとダメ
true:変数がある
flase:
    "" (空文字列)
    0 (整数 の 0)
    0.0 (浮動小数点数の 0)
    "0" (文字列 の 0)
    NULL
    FALSE
    array() (空の配列)

@new_intention
$error_msg
if(!empty($error_msg['pre'])
自身のページに戻って来て、都度array()で初期化している
$clean['school'],['intere']
最初はNULL

・isset($var)
$varは変数でないとダメ
true:変数がある
false:NULL

●メッセージページの非エラー時の処理
自身のページでエラー有無を確認する方法だと、エラーがない時次のページに飛んでしまう問題。